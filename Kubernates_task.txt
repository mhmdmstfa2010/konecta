###Please Explain all the instructions and commands you used to complete each Point in MD file
EX:
Q1:
explanation
Command used 
Output of the command 
Screenshot for terminal and browser in case exposing service  

- Provide YAML files for all Kubernetes objects created (namespace.yaml, deployments.yaml, service.yaml, etc.). Include the output of relevant kubectl commands that verify the successful completion of each step. Provide screenshots showing the services running and accessible
  

- Push all of them into your GitHub account.

=========
Part1:

1- create pod nginx with name my nginx direct from command don't use yaml file 

2- create pod nginx with name my nginx command and use Image nginx123  direct from command don't use yaml file

3- check the status and why it doesn't work 

4- I need to know node name - IP - Image Of the POD

5- delete the pod 

6- create another one with yaml file and use label

7-create Riplicaset with 3 replicas using nginx Image 

8-scale the replicas to 5 without edit in the Yaml file
 
9-Delete any one of the 5 pods and check what happen and explain 

10-Scale down the pods aging to 2 without scale command use terminal  

11- find out the issue in the below Yaml (don't use AI)

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replicaset-2
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: nginx
    spec:
      containers:
      - name: nginx
        image: nginx

12- find out the issue in the below Yaml (don't use AI)

apiVersion: apps/v1
kind: deployment
metadata:
  name: deployment-1
spec:
  replicas: 2
  selector:
    matchLabels:
      name: busybox-pod
  template:
    metadata:
      labels:
        name: busybox-pod
    spec:
      containers:
      - name: busybox-container
        image: busybox
        command:
        - sh
        - "-c"
        - echo Hello Kubernetes! && sleep 3600

13- find out the issue in the below Yaml (don't use AI)

apiVersion: v1
kind: Deployment
metadata:
  name: deployment-1
spec:
  replicas: 2
  selector:
    matchLabels:
      name: busybox-pod
  template:
    metadata:
      labels:
        name: busybox-pod
    spec:
      containers:
      - name: busybox-container
        image: busybox
        command:
        - sh
        - "-c"
        - echo Hello Kubernetes! && sleep 3600

14- what's command you use to know what Image name that running the deployment 


15- create deployment using following data :
Name: httpd-frontend;
Replicas: 3;
Image: httpd:2.4-alpine


16- replace the image to nginx777 with command directly 

17- rollback to pervious version

18- Create a Simple Web Application:
* Use a Dockerfile to create a simple web application (e.g., an Nginx server serving an HTML page).
* Build the Docker image and push it to DockerHub your private Account.

19- Create a Deployment Using This Image:
* Deploy the Docker image from DockerHub to Kubernetes with a Deployment that has 3 replicas.

20- Expose the Frontend (FE) Using Service to make it accessible from your browser.


21-Create a Backend (BE) Deployment:
* Create another Deployment for the backend using the following data:
Image: python:3.8-slim
Command: ["python", "-m", "http.server", "8080"] (include this command in the deployment file).

22- Expose the Backend Internally Using Service:
* Use kubectl command to make it accessible from your browser (without NodePort)

23- Create a LoadBalancer Service:
* Create a LoadBalancer service for your frontend.
* Explain what happens when you try to apply it in an environment that does not support load balancers (e.g., Minikube).

24-Explain DaemonSet and Provide a YAML File:
* Explain what a DaemonSet is and how it works.
* Provide a YAML file to create a DaemonSet in Kubernetes.

25- List the Components of the ** Master node ** and what is the purpose of each component 
26- List  the Components of the ** Worker node ** and what is the purpose of each component

===========
Advanced Parts - Bonus
===========
Part2
Search for:
- Namespace
- Configmap
- Secret 
- Network Policy
- Taint and toleration
- Volume
====
Part3:
Based on the search that you did:

1- start your minikube with 2 nodes 
2- create 3 namespaces 
   - FE  
   - mongo-db 
   - mongo-express

3- Deployments&services: 
    A-  simple web frontend application in the FE-namespace namespace with 2 riplca  - and Use an emptyDir Volume to store the web content and mount it to /usr/share/nginx/html in the POD - Create a NodePort Service named frontend-service to expose the Nginx application externally on port 80.


    b - Deploy a MongoDB database in the mongo-db namespace.
     Use a Deployment named mongodb-deployment with:
     1 replica.
     The image: mongo:latest
     Create a Secret named mongodb-secret in the mongo-db namespace to store the MongoDB root username (MONGO_INITDB_ROOT_USERNAME) and password (MONGO_INITDB_ROOT_PASSWORD).
     Root username: admin
     Root password: admin123
     Use a Persistent Volume and Persistent Volume Claim (PVC) named mongodb-pvc to store MongoDB data at /data/db.
     Create a ClusterIP Service named mongodb-service to expose the MongoDB database internally within the cluster on port 27017.

  c- Deploy Mongo Express in the mongo-express namespace.
     Use a Deployment named mongo-express-deployment with:
     1 replica.
     The image: mongo-express:latest.
     Create a ConfigMap named mongo-express-config in the mongo-express namespace to store environment variables for the Mongo Express application.
     Hint (you should accces the MongoDB by mongo-express deployment)
     Create a NodePort Service named mongo-express-service to expose the Mongo Express interface externally on port 8081.
  d- apply network policy in the namespace mongo-db to be accssiable from only mongo-express namespace

4- Use Taints and Tolerations:

a- Taint one of the Minikube nodes with key=db:NoSchedule.
b- Apply a Toleration in the mongodb-deployment to allow the MongoDB pod to be scheduled on the tainted node 

